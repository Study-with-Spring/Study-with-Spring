## 쿠키?

기존의 Http 프로토콜은 stateless, 즉 서버는 항상 클라이언트가 누군지 확인을 해야합니다. <br>
그래서 이를 보완하여 나온 것이 쿠키입니다. <br>

1. 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일

2. 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있습니다.

3. 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조합니다.<br>

   쿠키 위치는 운영체제와 브라우저의 종류에 따라 조금 다른데, 윈도우 크롬의 경우는 C:\Users\사용자명\AppData\Local\Google\Chrome\User Data\Default\Cookies 입니다.

4. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송합니다.

**쿠키 구성요소**

1. 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름
2. 값 : 쿠키의 이름과 관련된 값
3. 유효시간 : 쿠키의 유지시간
4. 도메인 : 쿠키를 전송할 도메인
5. 경로 : 쿠키를 전송할 요청 경로

**쿠키의 동작**

1. 클라이언트가 페이지를 요청

2. 서버에서 쿠키를 생성

3. HTTP 헤더에 쿠키를 포함 시켜 응답

4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음

5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄

6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

**쿠키, 캐시 차이점**

1. 캐시는 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것입니다.

2. 한번 캐시에 저장되면 브라우저를 참고하기 때문에 서버에서 변경이 되어도 사용자는 변경되지 않게 보일 수 있는데 이런 부분을 캐시를 지워주거나 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시하는 방법등을 이용할 수 있습니다.

## 세션

사용자가 브라우저를 닫아 서버와의 연결을 끝내는 시점까지를 세션이라고 합니다.

1. 세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리합니다.

2. 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지합니다.

3. 물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능 합니다.

4. 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 됩니다.

5. 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션 ID입니다.

**세션의 동작**

1. 클라이언트가 서버에 접속 시 세션 ID를 발급 받음

2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음

3. 클라리언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청

4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져와서 사용

5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답

**세션의 특징**

1. 각 클라이언트에게 고유 ID를 부여

2. 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공

3. 보안 면에서 쿠키보다 우수

4. 용자가 많아질수록 서버 메모리를 많이 차지하게 됨

## 쿠키와 세션의 차이점

1. 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문입니다.

2. 가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.

3. 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.

4. 보안, 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다.

5. 라이프 사이클, 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있습니다.

6. 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됩니다. 예를 들어, 크롬에서 다른 탭을 사용해도 세션을 공유됩니다. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있습니다.

7. 속도, 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 가집니다.

## JWT

세션은 사용자의 수만큼 서버 메모리를 사용하기 때문에 이런 문제들을 보완하기 위해 JWT를 사용합니다.

JWT는 토큰 기반 인증방식으로 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보를 포함하고 있습니다. 서버에서 인증된 JWT를 생성하여 클라이언트에 응답으로 보내주고, 클라이언트가 서버에 데이터를 요구하면 JWT를 HTTP 헤더에 담습니다. 서버는 이 JWT를 보고 클라이언트를 검증합니다.

데이터가 많아지게 되면 토큰이 커질 수 있으며 토큰이 한 번 발급 된 이후 사용자의 정보가 바뀌게 되더라도 반영되지 않습니다.

토큰은 클라이언트에 저장되기 때문에 서버의 부담을 줄여줍니다.

## 필터

필터는 요청과 응답을 거르고 정제하는 역할을 합니다.

Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공합니다.

즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리됩니다.

필터를 사용하기 위해서는 javax.servlet의 Filter 인터페이스를 구현(implements) 해야 합니다.

```java
public interface Filter {

    public default void init(FilterConfig filterConfig) throws ServletException {}

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException;

    public default void destroy() {}

}
```

```java
1. init() :

필터 객체를 초기화하고 서비스에 추가하기 위한 메소드이다.
웹 컨테이너가 1회 init()을 호출하여 필터 객체를 초기화하면 이후 요청들은 doFilter()를 통해 처리된다.

2. doFilter() :

url-pattern에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전에 웹 컨테이너에 의해 실행되는 메소드입니다.
doFilter의 파라미터로 FilterChain이 있는데, FilterChain 의 doFilter 통해 다음 대상으로 요청을 전달할 수 있게 됩니다.
chain.doFilter()로 전, 후에 우리가 필요한 처리 과정을 넣어줌으로써 원하는 처리를 진행할 수 있습니다.

3. destroy() :

필터 객체를 제거하고 사용하는 자원을 반환하기 위한 메소드입니다.
웹 컨테이너가 1회 destroy()를 호출하여 필터 객체를 종료하면 이후에는 doFilter에 의해 처리되지 않습니다.
```

## 인터셉트

1. 인터셉터(Interceptor)는 스프링(Spring)이 제공하는 기술로써 디스패처 서블릿(Dispatcher Servlet)이 컨트롤러를 호출하기 전과 후에 요청을 가로채서 응답을 참조하거나 가공할 수 있게 도와줍니다.

2. 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작합니다.

3. 디스패처 서블릿이 핸들러 매핑을 통해 컨트롤러를 찾도록 요청하는데, 그 결과로 실행 체인(HandlerExecutionChain)을 돌려줍니다.
   여기서 1개 이상의 인터셉터가 등록되어 있다면 순차적으로 인터셉터들을 거쳐 컨트롤러가 실행되도록 하고,
   인터셉터가 없다면 바로 컨트롤러를 실행합니다.

```java
//
public interface HandlerInterceptor {

	default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {

		return true;
	}

	default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			@Nullable ModelAndView modelAndView) throws Exception {
	}

	default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
			@Nullable Exception ex) throws Exception {
	}
}
```

```java
1. preHandle() :

- Controller가 호출되기 전에 실행됩니다.
컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용할 수 있습니다.
2. postHandle() :

- Controller가 호출된 후에 실행됩니다. ( View 렌더링 전)
컨트롤러 이후에 처리해야 하는 후처리 작업이 있을 때 사용할 수 있습니다. 이 메소드는 컨트롤러가 반환하는 ModelAndView 타입의 정보가 제공되는데, 최근에는 JSON 형태로 데이터를 제공하는 RestAPI 기반의 컨트롤러(@RestController)를 만들면서 자주 사용되지 않습니다.
3. afterCompletion() :

- 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행됩니다. ( View 렌더링 후)
요청 처리 중에 사용한 리소스를 반환할 때 사용할 수 있습니다.
```

**필터와 인터셉트 차이점**

필터와 인터셉터 모두 비즈니스 로직과 분리되어 특정 요구사항(보안, 인증, 인코딩 등)을 만족시켜야 할 때 적용하는데,
필터는 Request와 Response를 조작할 수 있지만, 인터셉터는 조작할 수 없습니다.

필터(Filter)는 특정 요청과 컨트롤러에 관계없이 전역적으로 처리해야 하는 작업이나 웹 어플리케이션에 전반적으로 사용되는 기능을 구현할 때 적용합니다.

인터셉터(Interceptor)는 클라이언트의 요청과 관련된 작업에 대해 추가적인 요구사항을 만족해야 할 때 적용합니다.
