# 스프링 스터디 3주차

---

### 1. 프론트 컨트롤러 패턴

- 프론트 컨트롤러 서블릭 하나로 클라이언트의 요청을 받음 → 컨트롤러 요청에 맞는 컨트롤러 찾아서 호출
- 입구를 하나로 하고, 공통 처리하는 기능이 추가
- 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

→ 스프링 웹 MVC의 DispatcherServlet이 프론트 컨트롤러 패턴으로 구현돼 있음

### 2. 단계별 프레임 워크 개선

- **v1 : 프론트 컨트롤러 도입(기능 추가 없음)**
    
    : 프론트 컨트롤러를 도입하면서 기존 URL 접근에 따른 컨트롤러 실행이 각각 이뤄졌던 것에 반해 모든 url 접근이 FronctCntroller를 통해 이뤄지게 됨
    
- **v2 : View 분류(View 호출 부분 중복 제거)**
    
    : View를 호출하는 부분의 중복을 막고자 FrontController에서 해당부분을 처리함. 각 컨트롤러에서 MyView 객체를 생성하고 이름만 넣은 채로 리턴하면 FrontController에 정의된 ViewRender 함수가 해당 View를 호출함. 
    
- **v3 : Model 추가(모델 객체 전달, 뷰 논리 이름 사용)**
    
    : 기존 서블릿을 상속받았던 각 컨트롤러에서 서블릿에 대한 종속성을 제거하고, 각 컨트롤러가 리턴하는 뷰 이름의 중복되는 부분을 제거. 서블릿의 request를 사용하지 않는 구조로 변경하기 때문에 프론트 컨트롤러에서 해당 request를 paraMap이라는 객체로 만들어 컨트롤러에 전달해준다. 리턴 받은 뷰 역시 간소화된 논리 이름을 사용하므로 이를 다시 원래 뷰를 호출하는데 필요한 나머지 정보들을 합치는 ViewResolver함수를 사용해 뷰를 호출한다.
    
- **v4 : 단순하고 실용적인 컨트롤러(모델 객체 프론트 컨트롤러에서 생성해 전달)**
    
    : 기존 v3에서는 렌더링에 필요한 데이터(모델)과 뷰 이름을 담은 ModelView 객체를 각 컨트롤러에서 생성했지만, v4에서는 이를 프론트 컨트롤러에서 생성해 컨트롤러의 매개변수로 넘기는 식으로 개선
    
- **v5 : 유연한 컨트롤러**
    
    : 어댑터라는 개념을 사용해 다양한 종류의 컨트롤러(핸들러)를 사용할 수 있게 한다.
    
    <aside>
    💡 1. request에 따라 해당 url 접근에 필요한 핸들러를 불러옴(핸들러 맵에 정의)
    2. 해당 핸들러를 철하는데 필요한 어댑터를 불러옴(어댑터 리스트에 정의)
    3. 해당 어댑터에 (request, response, handler)를 매개인자로 보내고 실행
    4. 어댑터에서는 해당 핸들러(Object로 선언)를 캐스팅해주고 해당 핸들러에 맞는 매개인자를 준비해 핸들러(controller)를 실행 
    5. 반환형은 ModelView로 통일시켜 어댑터에서 반환형을 통일해준다.
    
    </aside>